## Паттерны и их обоснование.

### Payment.
Используется паттерн `Chain of Responsibility`, позволяющий выстраивать
цепочки нужных операций.

Платежный интерфейс `PaymentContext` представлен паттерном `Strategy`, для удобного
переключения типов оплаты (кредитная карта, Pay Pal, Быстрый платеж и тд) на лету.

Это позволяет работать с оплатой через единый интерфейс, не зная деталей реализации.


### Catalog.
Использует паттерн `Factory Method`, поскольку этот паттерн обеспечивает легкое 
добавление/удаления новых категорий, без модификации другого кода.

Точнее можно сделать без модификации, если в фабрике вместо switch использовать Map<>.
Но в демонстрационном примере не вижу смысла так заморачиваться.


### Cart.
Используется паттерн `Strategy`. Позволяет легко менять стратегию работы с корзиной
для различных типов пользователей (авторизированные и анонимные).  

Легко добавляются новые стратегии, не затрагивая остальной бизнес-логики. 


### Order.
Используется паттерн `Saga`, поскольку позволяет легко задать не только очередность
выполнения действий, но и их откат в обратном порядке, в случае если на каком-то
действии произойдет ошибка.

Сущность `Order` реализована паттерном `Builder`. В данном случае нужда в нём притянута за уши,
но в качестве демонстрации вполне сойдет. 


## Spring Cloud Bus + RabbitMQ (с Management Plugin)
Это просто проба. По хорошему уведомления должен принимать отдельный микросервис,
который и будет рассылать их дальше, используя все доступные ему средства (смс, мыло, веб-сокеты и тд.).

Пробовал уведомления через e-mail, работает. Но для рассылки нужен токен от своей почты, поэтому
этот код не вошел в конечную версию: без него не работает, а светить его не хочу.

Запуск RabbitMQ (можно прямо из консоли IDEA):

```shell
docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:management
```
Порт 5672 — стандартный порт для AMQP-протокола.

Порт 15672 — для веб-интерфейса RabbitMQ Management.

Админка соответственно: http://localhost:15672

Пароль и логин: `guest`


## Разное.
Поскольку магазин может работать и с не авторизированными пользователями,
то для их идентификации используются куки. Веб-клиент генерирует anon_id
для каждого нового пользователя, пока он не авторизуется. Эти же
идентификационные куки передаются и в корзину, посредством встраивания
их в Feign-запросы, что позволяет корзине правильно идентифицировать и 
создавать отдельную корзину даже для анонимных пользователей.


## Примечание.
Уже когда почти все было написано, я понял одну вещь: для анонимов лучше создавать специальный
Jwt-токен с ограниченными правами (для чего на сервере Auth уже предусмотрен клиент с
ролью `SERVICE` и простой аутентификацией). Это избавит от просто огромного количества проблем,
как при идентификации пользователей, так и при подключении других зависимостей, поскольку 
в контексте Spring Security они требуют аутентификации (или опять же настраивать фильтры, 
что не очень удобно). Да и время сессии можно легко ограничить.
